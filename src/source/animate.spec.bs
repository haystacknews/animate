import "animate.bs"

namespace tests
@suite
class TestSuite extends rooibos.BaseTestSuite
    protected override function beforeEach()
    if (m.canvas = invalid)
        m.canvas = m.top.createChild("Group")
        m.canvas.id = "canvas"
    end if

    m.r1 = m.canvas.createChild("Rectangle")
    m.r1.id = "r1"

    m.r2 = m.canvas.createChild("Rectangle")
    m.r2.id = "r2"
    end function

    protected override function afterEach()
    m.resetCanvas()
    end function

    private function resetCanvas()
    if (m.canvas <> invalid)
        m.canvas.removeChildrenIndex(m.canvas.getChildCount(), 0)
    end if
    end function

    @describe("identifies targets")

    @it("by string id")
    function _()
        targets = getNodeTargets("r1 r2")
        m.assertArrayCount(targets, 2)
        m.assertSubType(targets[0], "Rectangle")
    end function

    @it("directly by node")
    function _()
        targets = getNodeTargets(m.r1)
        m.assertArrayCount(targets, 1)
        m.assertSubType(targets[0], "Rectangle")
    end function

    @it("by list of strings")
    function _()
        targets = getNodeTargets(["r1", "r2"])
        m.assertArrayCount(targets, 2)
    end function

    @it("by list of nodes")
    function _()
        targets = getNodeTargets([m.r1, m.r2])
        m.assertArrayCount(targets, 2)
    end function

    @it("by mixed list")
    function _()
        targets = getNodeTargets(["r1", m.r2])
        m.assertArrayCount(targets, 2)
    end function

    @describe("generates animation objects")

    @it("can use `targets` or `target` as key")
    function _()
        result = _animate({
            targets: "r1 r2",
            x: 20
        })
        m.assertEqual(result.subtype, animateUtils.NodeNames.ParallelAnimation)
        m.assertArrayCount(result.children, 2)

        result = _animate({
            target: "r1 r2",
            x: 20
        })
        m.assertEqual(result.subtype, animateUtils.NodeNames.ParallelAnimation)
        m.assertArrayCount(result.children, 2)
    end function

    @it("assigns ids to nodes without")
    function _()
        r = m.canvas.createChild("Rectangle")
        _animate({targets: r})
        m.assertTrue(r.id.startsWith("__animate_"))
    end function

    @it("considers animation and interpolator params")
    function _()
        result = _animate({
            targets: m.r1,
            duration: 33,
            key: [0, 0.2, 0.19, 0.9, 1],
            x: 20
        })

        m.assertEqual(result.subType, animateUtils.NodeNames.Animation)
        m.assertEqual(result.duration, 33)
        m.assertArrayCount(result.children, 1)
        m.assertArrayCount(result.children[0].key, 5)
        m.assertEqual(result.children[0].key[0], 0)
        m.assertEqual(result.children[0].key[1], 0.2)
        m.assertEqual(result.children[0].key[2], 0.19)
    end function

    @it("generates parallel animation for multiple targets")
    function _()
        result = _animate({
            targets: [m.r1, m.r2],
            x: 20
        })

        m.assertEqual(result.subtype, animateUtils.NodeNames.ParallelAnimation)
        m.assertArrayCount(result.children, 2)

        r1Animation = result.children[0]
        m.assertEqual(r1Animation.subtype, animateUtils.NodeNames.Animation)
        m.assertArrayCount(r1Animation.children, 1)
        
        r1Interp = r1Animation.children[0]

        m.assertEqual(r1Interp, {
            subtype: animateUtils.NodeNames.Vector2DFieldInterpolator,
            fieldToInterp: "r1.translation",
            key: [0, 1]
            keyValue: [[0, 0], [20, 0]]
        })

        r2Animation = result.children[1]
        m.assertEqual(r2Animation.subtype, animateUtils.NodeNames.Animation)
        m.assertArrayCount(r2Animation.children, 1)
        
        r2Interp = r2Animation.children[0]

        m.assertEqual(r2Interp, {
            subtype: animateUtils.NodeNames.Vector2DFieldInterpolator,
            fieldToInterp: "r2.translation",
            key: [0, 1]
            keyValue: [[0, 0], [20, 0]]
        })
    end function

    @it("ignores properties that can't be interpolated")
    function _()
        label = m.canvas.createChild("Label")
        label.text = "initial"
        result = _animate({
            targets: label,
            ' vector 2d field interp
            x: 20,
            ' color field interp 
            color: "#FF0000",
            ' float field interp
            opacity: 0.5,
            ' no interp
            text: "final"
        })

        m.assertEqual(result.subtype, animateUtils.NodeNames.Animation)
        m.assertArrayCount(result.children, 3)
        m.assertEqual(result.children[0].subtype, animateUtils.NodeNames.ColorFieldInterpolator)
        m.assertEqual(result.children[1].subtype, animateUtils.NodeNames.FloatFieldInterpolator)
        m.assertEqual(result.children[2].subtype, animateUtils.NodeNames.Vector2DFieldInterpolator)
    end function

    @describe("special interpolator keys")

    @it("x: moves element from current x to value")
    function _()
        m.r1.translation = [44, 33]
        result = _animate({
            target: m.r1,
            x: 20
        })

        m.assertEqual(result.children[0].keyValue, [[44, 33], [20, 33]])
    end function

    @it("y: moves element from current y to value")
    function _()
        m.r1.translation = [90, 24]
        result = _animate({
            target: m.r1,
            y: 87
        })

        m.assertEqual(result.children[0].keyValue, [[90, 24], [90, 87]])
    end function

    @it("translateX: moves element from current x to (current x + value)")
    function _()
        m.r1.translation = [44, 33]
        result = _animate({
            target: m.r1,
            translateX: 20
        })

        m.assertEqual(result.children[0].keyValue, [[44, 33], [64, 33]])
    end function

    @it("translateY: moves element from current y to (current y + value)")
    function _()
        m.r1.translation = [90, 24]
        result = _animate({
            target: m.r1,
            translateY: 87
        })

        m.assertEqual(result.children[0].keyValue, [[90, 24], [90, 111]])
    end function

    @describe("special interpolator values")

    @it("rotation in degrees is transformed to radians")
    function _()
        result = _animate({
            target: m.r1,
            rotation: "90deg"
        })

        m.assertEqual(result.children[0].keyValue, [0, 1.5708])
    end function

    @it("single value for scale is expanded to array")
    function _()
        result = _animate({
            target: m.r1,
            scale: 2
        })

        m.assertEqual(result.children[0].keyValue, [[1, 1], [2, 2]])
    end function

    @describe("object properties")

    @it("specific parameters per property")
    function _()
        result = _animate({
            targets: m.r1,
            translateX: {
                value: 450,
                duration: 0.8,
                easeFunction: "linear"
            },
            rotation: {
                value: "-360deg",
                duration: 1.8
            },
            scale: {
                value: 2,
                duration: 1.6,
                ' all the other animations will inherit delay = 0.25
                ' except this one
                delay: 0.8,
                easeFunction: "inOutQuartic"
            },
            color: "#FAFA33",
            delay: 0.25
        })
        
        m.assertEqual(result.subtype, animateUtils.NodeNames.ParallelAnimation)
        m.assertArrayCount(result.children, 4)

        ' Roku automatically transforms AAs to have
        ' their keys alphabetically ordered.
        ' So we can expect to have the result children
        ' in order: color, rotation, scale, translation

        colorAnim = result.children[0]
        rotationAnim = result.children[1]
        scaleAnim = result.children[2]
        translationAnim = result.children[3]

        ' confirm that interpolators have correct values

        m.assertEqual(colorAnim.children[0].subtype, animateUtils.NodeNames.ColorFieldInterpolator)
        m.assertEqual(colorAnim.children[0].fieldToInterp, "r1.color")

        m.assertEqual(rotationAnim.children[0].subtype, animateUtils.NodeNames.FloatFieldInterpolator)
        m.assertEqual(rotationAnim.children[0].fieldToInterp, "r1.rotation")
    
        m.assertEqual(scaleAnim.children[0].subtype, animateUtils.NodeNames.Vector2DFieldInterpolator)
        m.assertEqual(scaleAnim.children[0].fieldToInterp, "r1.scale")

        m.assertEqual(translationAnim.children[0].subtype, animateUtils.NodeNames.Vector2DFieldInterpolator)
        m.assertEqual(translationAnim.children[0].fieldToInterp, "r1.translation")

        ' confirm that animations are inheriting root
        ' level values but conserving their specific values

        m.assertEqual(translationAnim.duration, 0.8)
        m.assertEqual(translationAnim.delay, 0.25)

        m.assertEqual(rotationAnim.duration, 1.8)
        m.assertEqual(rotationAnim.delay, 0.25)

        m.assertEqual(scaleAnim.duration, 1.6)
        m.assertEqual(scaleAnim.delay, 0.8)

        m.assertEqual(colorAnim.duration, 1)
        m.assertEqual(colorAnim.delay, 0.25)
    end function

    @describe("direction and keys")

    @it("normal")
    function _()
        result = _animate({
            target: m.r1,
            translateX: 250,
            direction: "normal"
        })

        m.assertEqual(result.children[0].keyValue, [[0, 0], [250, 0]])
        m.assertEqual(result.children[0].key, [0, 1])
    end function

    @it("reverse")
    function _()
        result = _animate({
            target: m.r1,
            translateX: 250,
            direction: "reverse"
        })

        m.assertEqual(result.children[0].keyValue, [[250, 0], [0, 0]])
        m.assertEqual(result.children[0].key, [0, 1])
    end function

    @it("alternate")
    function _()
        result = _animate({
            target: m.r1,
            translateX: 250,
            direction: "alternate"
        })

        m.assertEqual(result.children[0].keyValue, [[0, 0], [250, 0], [0, 0]])
        m.assertEqual(result.children[0].key, [0, 0.5, 1])
    end function
end class
end namespace
