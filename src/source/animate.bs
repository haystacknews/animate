function animate(params as object) as object
    animations = _animate(params)
    if (animations.count() = 1)
        return animateUtils.createNodeFromAA(animations[0])
    end if

    return animateUtils.createNodeFromAA({
        subtype: "ParallelAnimation",
        children: animations
    })
end function

function _animate(params as object) as object
    animations = []
    animationParams = animateUtils.extractAnimationParams(params)
    if (animationParams.duration = invalid)
        animationParams.duration = 1
    end if

    for each animationKey in animationParams.keys()
        params.delete(animationKey)
    end for

    nodeTargets = getNodeTargets(params.targets)
    params.delete("targets")

    for each nodeTarget in nodeTargets
        if (nodeTarget.id = invalid or nodeTarget.id = "")
            nodeTarget.id = `__animate_${rnd(42069)}` ' nice
        end if

        animation = {
            subtype: "Animation",
            children: getTargetInterpolators(nodeTarget, params)
        }
        animation.append(animationParams)
        animations.push(animation)
    end for

    return animations
end function

function getTargetInterpolators(nodeTarget as object, params as object) as object
    interpolators = []

    for each item in params.items()
        ' Thanks Roku for not letting us split if statements
        ' in multiple lines. This is very readable! :)
        if (is.valid(item.value) and (is.special.prop(item.key) or nodeTarget.hasField(item.key)))
            interpolator = getPropertyInterpolator(nodeTarget, item.key, item.value)
            if (interpolator <> invalid)
                interpolators.push(interpolator)
            end if
        end if
    end for
    return interpolators
end function

function getPropertyInterpolator(nodeTarget as object, property as string, value as dynamic) as dynamic
    if (property = "translation" and is.arr2d(value))
        value = [
            nodeTarget.translation[0] + value[0],
            nodeTarget.translation[1] + value[1]
        ]
    end if

    if (is.special.translation(property))
        if (animateUtils.compareFieldStrings(property, "x"))
            value = [value, nodeTarget.translation[1]]
        else if (animateUtils.compareFieldStrings(property, "y"))
            value = [nodeTarget.translation[0], value]
        else if (animateUtils.compareFieldStrings(property, "translateX"))
            currentX = nodeTarget.translation[0]
            value = [currentX + value, nodeTarget.translation[1]]
        else if (animateUtils.compareFieldStrings(property, "translateY"))
            currentY = nodeTarget.translation[1]
            value = [nodeTarget.translation[0], currentY + value]
        end if
        property = "translation"
    end if

    if (property = "rotation" and is.str(value) and value.endsWith("deg"))
        degrees = value.tokenize("deg")[0].toFloat()
        value = degrees * 0.01745329
    end if

    if (property = "scale" and is.number(value))
        value = [value, value]
    end if

    currentValue = nodeTarget[property]

    interpolator = {}
    if (property = "color")
        interpolator.subtype = "ColorFieldInterpolator"
    else if (is.arr2d(value))
        interpolator.subtype = "Vector2DFieldInterpolator"
    else if (is.number(value))
        interpolator.subtype = "FloatFieldInterpolator"
    else
        return invalid
    end if

    interpolator.append({
        fieldToInterp: `${nodeTarget.id}.${property}`,
        key: [0, 1],
        keyValue: [currentValue, value]
    })

    return interpolator
end function

function getNodeTargets(targets as dynamic) as object
    nodeTargets = []

    if (is.str(targets))
        ' For a string `targets`, we split by spaces
        ' and try to find the nodes in the current `m.top` scope.
        ids = targets.tokenize(" ")
        for each id in ids
            nodeTarget = m.top.findNode(id)
            if (is.valid(nodeTarget))
                nodeTargets.push(nodeTarget)
            end if
        end for
    else if (is.arr(targets))
        ' For array targets, we recursively find targets inside
        ' each element.
        for each target in targets
            nodeTargets.append(getNodeTargets(target))
        end for
    else if (is._node(targets))
        ' For nodes we consider them directly
        nodeTargets.push(targets)
    end if

    return nodeTargets
end function

namespace is
    function valid(x as dynamic) as boolean
        return x <> invalid
    end function
    
    function str(x as dynamic) as boolean
        return is.valid(x) and getInterface(x, "ifString") <> invalid
    end function

    function arr(x as dynamic) as boolean
        return is.valid(x) and getInterface(x, "ifArray") <> invalid
    end function

    function integer(x as dynamic) as boolean
        return is.valid(x) and getInterface(x, "ifInt") <> invalid and (type(x) = "roInt" or type(x) = "roInteger" or type(x) = "Integer")
    end function

    function float(x as dynamic) as boolean
        return is.valid(x) and (getInterface(x, "ifFloat") <> invalid or (type(x) = "roFloat" Or type(x) = "Float"))
    end function

    function number(x as dynamic) as boolean
        return is.float(x) or is.integer(x)
    end function

    function _node(x as dynamic) as boolean
        return is.valid(x) and getInterface(x, "ifSGNodeField") <> invalid
    end function

    function arr2d(x as dynamic) as boolean
        return is.valid(x) and is.arr(x) and x.count() = 2 and is.number(x[0]) and is.number(x[1])
    end function

    namespace special
        function prop(x as dynamic) as boolean
            return is.special.translation(x)
        end function

        function translation(x as dynamic) as boolean
            if (not is.str(x))
                return false
            end if
    
            specialProperties = ["x", "y", "translateX", "translateY"]
            for each specialProperty in specialProperties
                if (animateUtils.compareFieldStrings(specialProperty, x))
                    return true
                end if
            end for
    
            return false
        end function
    end namespace
end namespace

namespace animateUtils
    function createNodeFromAA(aa as object) as object
        node = CreateObject("roSGNode", aa.subtype)
        aa.delete("subtype")
        node.update(aa)
        return node
    end function

    function compareFieldStrings(x as string, y as string) as boolean
        return lcase(x) = lcase(y)
    end function

    function getAnimationParams() as object
        return [
            "repeat",
            "delay",
            "duration",
            "easeFunction",
            "easeInPercent",
            "easeOutPercent",
            "optional"
        ]
    end function

    function extractAnimationParams(params as object) as object
        result = {}
        for each animationParam in animateUtils.getAnimationParams()
            if (params[animationParam] <> invalid)
                result[animationParam] = params[animationParam]
            end if
        end for
        return result
    end function
end namespace
